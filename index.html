<!DOCTYPE html>
<html>
<head>
  <title>Spacewars Game</title>
  <style>
    canvas {
      border: 1px solid black;
      background-color: black;
    }
   #joystick {
    position: absolute;
    bottom: 10%;
    left: 10%;
    width: 100px;
    height: 100px;
    background-color: rgba(0, 0, 0, 0.5);
    border-radius: 50%;
    touch-action: none;
  }
  #joystickHandle {
    position: absolute;
    top: 50%;
    left: 50%;
    width: 40px;
    height: 40px;
    background-color: rgba(255, 255, 255, 0.8);
    border-radius: 50%;
    transform: translate(-50%, -50%);
    touch-action: none;
  }
  #marketplace {
    display: none;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: white;
    padding: 20px;
    border: 1px solid black;
    width: 90%;
    max-width: 40 q0px;
    box-sizing: border-box;
  }
  #marketplace button {
    font-size: 18px; /* Increase button font size */
    padding: 10px; /* Increase button padding */
    margin: 5px 0; /* Add margin for better spacing */
  }
  #restartButton {
    position: absolute;
    top: 70%;
    left: 50%;
    transform: translate(-50%, -50%);
    padding: 20px 40px;
    font-size: 24px;
    display: none;
    background-color: white;
    border: 2px solid black;
    border-radius: 5px;
    cursor: pointer;
  }


  </style>
</head>
<body>
  <canvas id="gameCanvas" width="800" height="600"></canvas>
  <div id="joystick">
    <div id="joystickHandle"></div>

  </div>

  <div id="marketplace">
		<h2>Marketplace</h2>
		<p>Coins: <span id="coins">0</span></p>
		<button onclick="upgrade('lasers')">Upgrade Lasers (Cost: 100)</button> Level: <span id="laserLevel">1</span><br>
		<button onclick="upgrade('acceleration')">Upgrade Acceleration (Cost: 100)</button> Level: <span id="accelerationLevel">1</span><br>
		<button onclick="upgrade('rotationSpeed')">Upgrade Rotation Speed (Cost: 100)</button> Level: <span id="rotationSpeedLevel">1</span><br>
		<button onclick="buyDrone()">Buy Drone (Cost: 1000)</button><br>
		<button onclick="upgradeDrone('speed')">Upgrade Drone Speed (Cost: 200)</button> Level: <span id="droneSpeedLevel">1</span><br>
		<button onclick="upgradeDrone('laserSpeed')">Upgrade Drone Laser Speed (Cost: 200)</button> Level: <span id="droneLaserSpeedLevel">1</span><br>
		<button onclick="upgradeDrone('laserInterval')">Upgrade Drone Laser Interval (Cost: 200)</button> Level: <span id="droneLaserIntervalLevel">1</span><br>
		<button onclick="exitMarketplace()">Exit Marketplace</button>
  </div>
  <button id="restartButton" style="display: none;">Restart</button>

  <script src="https://telegram.org/js/games.js"></script>
  <script>
    // Get the canvas element
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const joystick = document.getElementById('joystick');
	const joystickHandle = document.getElementById('joystickHandle');
	const restartButton = document.getElementById('restartButton');

	let isTouchingJoystick = false;
	let joystickStartX, joystickStartY;

    const marketplace = document.getElementById('marketplace');
    const coinsDisplay = document.getElementById('coins');

	const laserLevelDisplay = document.getElementById('laserLevel');
	const accelerationLevelDisplay = document.getElementById('accelerationLevel');
	const rotationSpeedLevelDisplay = document.getElementById('rotationSpeedLevel');
	const droneSpeedLevelDisplay = document.getElementById('droneSpeedLevel');
	const droneLaserSpeedLevelDisplay = document.getElementById('droneLaserSpeedLevel');
	const droneLaserIntervalLevelDisplay = document.getElementById('droneLaserIntervalLevel');

    let superWeapons = {
      missile: 0,
      laser: 0,
      bomb: 0
    };

    let ship = {
      x: canvas.width / 2,
      y: canvas.height - 50,
      size: 20,
      speed: 0,
      acceleration: 0.1,
      deceleration: 0.99,
      maxSpeed: 2,
      rotation: 0,
      rotationSpeed: 4.5,
      lasers: [],
      velocityX: 0,
      velocityY: 0,
      laserLevel: 1,
      accelerationLevel: 1,
      rotationSpeedLevel: 1
    };

    let drone = {
      x: canvas.width / 2,
      y: canvas.height / 2,
      size: 10,
      speed: 0.0001,
      direction: Math.random() * Math.PI * 2,
      lasers: [],
      laserSpeed: 3,
      laserInterval: 120, // Fire lasers every 120 frames (2 second)
      laserTimer: 0
    };

	let upgrades = {
	  explosiveLasers: 0, // Initial level of explosive lasers
	  emp: 0
	};


const resizeCanvas = () => {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  // Scale the canvas to handle high DPI screens
  // ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

  // // Reposition the ship to the center of the canvas
  // ship.x = canvas.width / 2 / window.devicePixelRatio;
  // ship.y = canvas.height - 50 / window.devicePixelRatio;
};
		resizeCanvas();
		

// KEY CONFIG VARs
    let coins = 0;


    let score = 0;
    let asteroids = [];
    let gameLoop;
    let explosions = [];
    let lives = 3;
    let gameOver = false;
    let invincible = false;
    let invincibilityTimer = 0;
    const invincibilityDuration = 120; // 2 seconds (60 FPS)
    let wave = 1;
    let waveMessageTimer = 0;
    const waveMessageDuration = 180; // 3 seconds (60 FPS)
    let asteroidsKilled = 0;
	let drones = [];
	const droneCost = 1000;
	
	let bonusCoins = 0;

	let droneUpgrades = {
	  speed: 1,
	  laserSpeed: 1,
	  laserInterval: 1
	};


    // Event listeners for keyboard input
    document.addEventListener('keydown', handleKeyDown);
    document.addEventListener('keyup', handleKeyUp);



	// canvas.addEventListener('touchmove', (e) => {
	//   if (isTouching) {
	//     let touchX = e.touches[0].clientX;
	//     let touchY = e.touches[0].clientY;
	//     let deltaX = touchX - touchStartX;
	//     let deltaY = touchY - touchStartY;

	//     ship.rotation = Math.atan2(deltaY, deltaX) * (180 / Math.PI);
	//     ship.speed = Math.min(Math.sqrt(deltaX * deltaX + deltaY * deltaY) / 15, ship.maxSpeed); // Changed divisor from 10 to 5 for easier control

	//     touchStartX = touchX;
	//     touchStartY = touchY;
	//   }
	// });

	canvas.addEventListener('touchstart', (e) => {

		// lower left corner to acces sstore
		if (e.touches[0].clientX < canvas.width / 5 && e.touches[0].clientY > canvas.height * 4 / 5) {
	    pauseGameForMarketplace();
	  }

	  if (e.target === canvas && e.touches.length === 2) { // Require two fingers to fire
	    ship.lasers.push({ x: ship.x, y: ship.y, rotation: ship.rotation, size: 2 });
	  }
	});

    // Game loop
    function startGame() {
      createAsteroids();
      invincible = true;
      invincibilityTimer = invincibilityDuration;
      gameLoop = setInterval(update, 1000 / 60); // 60 FPS
    }

function update() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  let angle = ship.rotation * Math.PI / 180;
  ship.velocityX += ship.speed * Math.sin(angle);
  ship.velocityY -= ship.speed * Math.cos(angle);

  ship.x += ship.velocityX;
  ship.y += ship.velocityY;

  ship.velocityX *= ship.deceleration;
  ship.velocityY *= ship.deceleration;

  if (ship.x < 0) ship.x = canvas.width;
  else if (ship.x > canvas.width) ship.x = 0;
  if (ship.y < 0) ship.y = canvas.height;
  else if (ship.y > canvas.height) ship.y = 0;

  drawShip();
  updateLasers();
  drawLasers();
  updateDrones();
  drawDrones();
  updateAsteroids();
  drawAsteroids();

  if (!invincible) {
    for (let i = 0; i < asteroids.length; i++) {
      if (isColliding(ship, asteroids[i])) {
        createExplosion(ship.x, ship.y);
        resetShip();
        lives--;
        updateCoinsDisplay();
        invincible = true;
        invincibilityTimer = invincibilityDuration;
        if (lives === 0) gameOver = true;
        else pauseGameForMarketplace();
        break;
      }
    }
  }

  checkLaserCollisions(ship.lasers, true);

  if (invincible) {
    invincibilityTimer--;
    if (invincibilityTimer <= 0) invincible = false;
  }

  drawLives();
  drawScore();
  drawCoins();
  updateExplosions();
  drawExplosions();

  if (asteroids.length === 0 && !gameOver) {
    wave++;
    createAsteroids();
    invincible = true;
    invincibilityTimer = invincibilityDuration;
    waveMessageTimer = waveMessageDuration;
  }

  if (waveMessageTimer > 0) {
    drawWaveMessage();
    waveMessageTimer--;
  }

  if (gameOver) endGame();
}


function activateExplosiveLasers() {
  upgrades.explosiveLasers = true;
}


// Function to handle laser collisions
function checkLaserCollisions(lasers, isShip) {
  for (let i = lasers.length - 1; i >= 0; i--) {
    let laser = lasers[i];
    for (let j = asteroids.length - 1; j >= 0; j--) {
      let asteroid = asteroids[j];
      if (isColliding(laser, asteroid)) {
        createExplosion(asteroid.x, asteroid.y);
        if (upgrades.explosiveLasers) {
          // Create additional explosions for nearby objects
          createAreaDamage(asteroid.x, asteroid.y, 50); // 50 is the radius of the explosion
        }
        asteroids.splice(j, 1);
        lasers.splice(i, 1);
        score += 50;
        asteroidsKilled++;
        if (isShip) {
          coins += 10; // Add coins when score increases
          updateCoinsDisplay();
        }
        break;
      }
    }
  }
}


// Function to buy drones
function buyDrone() {
  if (coins >= droneCost) {
    coins -= droneCost;
    let drone = {
      x: canvas.width / 2,
      y: canvas.height / 2,
      size: 10,
      speed: 0.5 * droneUpgrades.speed,
      direction: Math.random() * Math.PI * 2,
      lasers: [],
      laserSpeed: 2 * droneUpgrades.laserSpeed,
      laserInterval: 240 / droneUpgrades.laserInterval, // Fire lasers more frequently as the interval increases
      laserTimer: 0
    };
    drones.push(drone);
    updateCoinsDisplay();
  }
}

function upgradeDrone(attribute) {
  const cost = 200;
  if (coins >= cost) {
    coins -= cost;
    droneUpgrades[attribute]++;

    // Update existing drones with new upgrade levels
    drones.forEach(drone => {
      switch (attribute) {
        case 'speed':
          drone.speed = 2 * droneUpgrades.speed;
          break;
        case 'laserSpeed':
          drone.laserSpeed = 5 * droneUpgrades.laserSpeed;
          break;
        case 'laserInterval':
          drone.laserInterval = 60 / droneUpgrades.laserInterval;
          break;
      }
    });
    updateCoinsDisplay();
    updateMarketplaceDisplay();

  }
}

// Update all drones
function updateDrones() {
  drones.forEach(drone => {
    const dx = ship.x - drone.x;
    const dy = ship.y - drone.y;
    const distance = Math.sqrt(dx * dx + dy * dy);

    if (distance > 200) { // If the drone is too far from the ship
      const angleToShip = Math.atan2(dy, dx);
      drone.direction = angleToShip; // Change direction towards the ship
    }

    drone.x += Math.cos(drone.direction) * drone.speed;
    drone.y += Math.sin(drone.direction) * drone.speed;

    if (drone.x < 0) drone.x = canvas.width;
    else if (drone.x > canvas.width) drone.x = 0;
    if (drone.y < 0) drone.y = canvas.height;
    else if (drone.y > canvas.height) drone.y = 0;

    for (let i = drone.lasers.length - 1; i >= 0; i--) {
      let laser = drone.lasers[i];
      laser.x += Math.cos(laser.direction) * drone.laserSpeed;
      laser.y += Math.sin(laser.direction) * drone.laserSpeed;

      if (laser.x < 0 || laser.x > canvas.width || laser.y < 0 || laser.y > canvas.height) {
        drone.lasers.splice(i, 1);
      }
    }

    drone.laserTimer++;
    if (drone.laserTimer >= drone.laserInterval) {
      drone.laserTimer = 0;
      let laser = {
        x: drone.x,
        y: drone.y,
        direction: Math.random() * Math.PI * 2,
        size: 2
      };
      drone.lasers.push(laser);
    }

    checkLaserCollisions(drone.lasers, false);
  });
}

function drawDrones() {
  drones.forEach(drone => {
    ctx.save();
    ctx.translate(drone.x, drone.y);
    ctx.rotate(drone.direction);
    ctx.beginPath();
    ctx.moveTo(0, -drone.size);
    ctx.lineTo(-drone.size, drone.size);
    ctx.lineTo(drone.size, drone.size);
    ctx.closePath();
    ctx.fillStyle = 'cyan';
    ctx.fill();
    ctx.restore();

    ctx.fillStyle = 'cyan';
    for (let i = 0; i < drone.lasers.length; i++) {
      let laser = drone.lasers[i];
      ctx.fillRect(laser.x - 1, laser.y - 1, 2, 2);
    }
  });
}

    function drawLives() {
      ctx.fillStyle = 'white';
      ctx.font = '20px Arial';
      ctx.textAlign = 'right';
      ctx.fillText('Lives: ' + lives, canvas.width - 20, 30);
    }

    function drawCoins() {
      ctx.fillStyle = 'white';
      ctx.font = '20px Arial';
      ctx.textAlign = 'left';
      ctx.fillText('Coins: ' + coins + "    's' for store", 20, canvas.height - 30);
    }

    // function drawDrone() {
    //   ctx.save();
    //   ctx.translate(drone.x, drone.y);
    //   ctx.rotate(drone.direction);
    //   ctx.beginPath();
    //   ctx.moveTo(0, -drone.size);
    //   ctx.lineTo(-drone.size, drone.size);
    //   ctx.lineTo(drone.size, drone.size);
    //   ctx.closePath();
    //   ctx.fillStyle = 'cyan';
    //   ctx.fill();
    //   ctx.restore();

    //   // Draw drone lasers
    //   ctx.fillStyle = 'cyan';
    //   for (let i = 0; i < drone.lasers.length; i++) {
    //     let laser = drone.lasers[i];
    //     ctx.fillRect(laser.x - 1, laser.y - 1, 2, 2);
    //   }
    // }

function endGame() {
  clearInterval(gameLoop);
  ctx.fillStyle = 'white';
  ctx.font = '40px Arial';
  ctx.textAlign = 'center';
  ctx.fillText('Game Over', canvas.width / 2, canvas.height / 2);
  ctx.font = '20px Arial';
  ctx.fillText(`Score: ${score}`, canvas.width / 2, canvas.height / 2 + 40);
  ctx.fillText(`Asteroids Destroyed: ${asteroidsKilled}`, canvas.width / 2, canvas.height / 2 + 70);

  // Calculate and display coins for next round
  bonusCoins = Math.floor(score * 0.06);
  coins += bonusCoins;
  ctx.fillText(`Bonus Coins for Next Round: ${bonusCoins}`, canvas.width / 2, canvas.height / 2 + 100);

  // Show the restart button
  restartButton.style.display = 'block';

  const tgShareScoreUrl = decodeURIComponent(window.location.href.split('tgShareScoreUrl=')[1]);
  window.TelegramGameProxy.shareScore(score);
}

    function pauseGameForMarketplace() {
      clearInterval(gameLoop);
      marketplace.style.display = 'block';
    }

	function exitMarketplace() {
	  marketplace.style.display = 'none';
	  invincible = true;
	  invincibilityTimer = invincibilityDuration;
	  updateMarketplaceDisplay(); // Update display to reflect current levels
	  gameLoop = setInterval(update, 1000 / 60); // Resume game loop
	}

    function upgrade(attribute) {
      const cost = 100;
      if (coins >= cost) {
        coins -= cost;
        switch (attribute) {
          case 'lasers':
            ship.laserLevel++;
            break;
          case 'acceleration':
            ship.accelerationLevel++;
            ship.acceleration = 0.1 * ship.accelerationLevel;
            break;
          case 'rotationSpeed':
            ship.rotationSpeedLevel++;
            ship.rotationSpeed = 2 * ship.rotationSpeedLevel;
            break;
        }
        updateMarketplaceDisplay();
        updateCoinsDisplay();
      }
    }

    function updateCoinsDisplay() {
      coinsDisplay.textContent = coins;
    }

    // Draw the ship
    function drawShip() {
      if (!invincible || (invincibilityTimer % 20 < 10)) {
        ctx.save();
        ctx.translate(ship.x, ship.y);
        ctx.rotate(ship.rotation * Math.PI / 180);
        ctx.beginPath();
        ctx.moveTo(0, -ship.size);
        ctx.lineTo(-ship.size, ship.size);
        ctx.lineTo(ship.size, ship.size);
        ctx.closePath();
        ctx.fillStyle = 'white';
        ctx.fill();
        ctx.restore();
      }
    }

    // Draw lasers
    function drawLasers() {
      ctx.fillStyle = 'red';
      for (let i = 0; i < ship.lasers.length; i++) {
        ctx.fillRect(ship.lasers[i].x - 1, ship.lasers[i].y - 1, ship.laserLevel + 3, ship.laserLevel + 3); // Drawing lasers as small squares for better collision detection
      }
    }

    // Update lasers
    function updateLasers() {
      for (let i = 0; i < ship.lasers.length; i++) {
        let laser = ship.lasers[i];
        laser.x += 10 * Math.sin(laser.rotation * Math.PI / 180);
        laser.y -= 10 * Math.cos(laser.rotation * Math.PI / 180);

        // Remove lasers that are off-screen
        if (laser.x < 0 || laser.x > canvas.width || laser.y < 0 || laser.y > canvas.height) {
          ship.lasers.splice(i, 1);
          i--;
        }
      }
    }

	function isColliding(obj1, obj2) {
	  let dx = obj1.x - obj2.x;
	  let dy = obj1.y - obj2.y;
	  let distance = Math.sqrt(dx * dx + dy * dy);
	  return distance < (obj1.size || 1) + obj2.size;
	}


   let chanceForSmallAsteroid = 1; // Start with a 1% chance
   let chanceForVerySmallAsteroid = 0.1; // Start with a 0.1% chance

   // IDEA: implement hardened 

	function createAsteroids() {
	  let numberOfAsteroids = 10 + (wave - 1) * 1.5;
	  for (let i = 0; i < numberOfAsteroids; i++) {
	    let isSmallAsteroid = Math.random() * 100 < chanceForSmallAsteroid;
	    let isVerySmallAsteroid = Math.random() * 100 < chanceForVerySmallAsteroid;
	    let asteroidSize = isSmallAsteroid ? 10 : 20; // Smaller asteroids have a size of 10
	    let asteroidSpeedMultiplier = isSmallAsteroid ? 1.5 : 1; // Smaller asteroids move 1.5 times faster
	    if(isVerySmallAsteroid) {
	    	asteroidSize = 5;
	    }

	    let asteroid = {
	      x: Math.random() * canvas.width,
	      y: Math.random() * canvas.height,
	      size: asteroidSize,
	      speed: asteroidSpeedMultiplier * (1 * Math.pow(1.05, wave - 1)),
	      dx: (Math.random() * 2 - 1) * asteroidSpeedMultiplier * Math.pow(1.05, wave - 1),
	      dy: (Math.random() * 2 - 1) * asteroidSpeedMultiplier * Math.pow(1.05, wave - 1)
	    };
	    asteroids.push(asteroid);
	  }
	  chanceForSmallAsteroid += 0.5; // Increase the chance by 0.5% each round
	  chanceForVerySmallAsteroid += 0.1; // Increase the chance by 0.1% each round
	}

    function drawScore() {
      ctx.fillStyle = 'white';
      ctx.font = '20px Arial';
      ctx.textAlign = 'left';
      ctx.fillText('Score: ' + score, 20, 30);
    }

    // Draw wave message
    function drawWaveMessage() {
      ctx.fillStyle = 'white';
      ctx.font = '40px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('Wave ' + wave, canvas.width / 2, canvas.height / 2);
    }

    // Update asteroids
    function updateAsteroids() {
      for (let i = 0; i < asteroids.length; i++) {
        asteroids[i].x += asteroids[i].dx * asteroids[i].speed;
        asteroids[i].y += asteroids[i].dy * asteroids[i].speed;

        // Wrap asteroids around the screen
        if (asteroids[i].x < 0) {
          asteroids[i].x = canvas.width;
        } else if (asteroids[i].x > canvas.width) {
          asteroids[i].x = 0;
        }
        if (asteroids[i].y < 0) {
          asteroids[i].y = canvas.height;
        } else if (asteroids[i].y > canvas.height) {
          asteroids[i].y = 0;
        }
      }
    }

    // Draw asteroids
    function drawAsteroids() {
      ctx.fillStyle = 'gray';
      for (let i = 0; i < asteroids.length; i++) {
        ctx.beginPath();
        ctx.arc(asteroids[i].x, asteroids[i].y, asteroids[i].size, 0, Math.PI * 2);
        ctx.closePath();
        ctx.fill();
      }
    }

	// Helper function to generate random shades of orange
	function getRandomOrangeShade() {
	  const r = 255;
	  const g = Math.floor(Math.random() * 156) + 100; // Random value between 100 and 255
	  const b = 0;
	  return `rgb(${r}, ${g}, ${b})`;
	}

	// Function to create area damage
	function createAreaDamage(x, y, radius) {
	  for (let i = asteroids.length - 1; i >= 0; i--) {
	    let asteroid = asteroids[i];
	    let dx = asteroid.x - x;
	    let dy = asteroid.y - y;
	    let distance = Math.sqrt(dx * dx + dy * dy);
	    if (distance < radius) {
	      createExplosion(asteroid.x, asteroid.y);
	      asteroids.splice(i, 1);
	      score += 50;
	    }
	  }
	}


	// Create explosions with randomness
	function createExplosion(x, y) {
	  const randomSize = Math.random() * 20 + 20; // Random size between 20 and 40
	  const randomAlphaDecay = Math.random() * 0.01 + 0.005; // Random alpha decay between 0.005 and 0.015
	  const randomColor = getRandomOrangeShade();

	  let explosion = {
	    x: x,
	    y: y,
	    size: randomSize,
	    alpha: 1,
	    alphaDecay: randomAlphaDecay,
	    color: randomColor
	  };
	  explosions.push(explosion);
	}

	// Update explosions with random alpha decay
	function updateExplosions() {
	  for (let i = 0; i < explosions.length; i++) {
	    explosions[i].size += 1;
	    explosions[i].alpha -= explosions[i].alphaDecay;
	    if (explosions[i].alpha <= 0) {
	      explosions.splice(i, 1);
	      i--;
	    }
	  }
	}

	// Draw explosions with random colors
	function drawExplosions() {
	  for (let i = 0; i < explosions.length; i++) {
	    ctx.save();
	    ctx.globalAlpha = explosions[i].alpha;
	    ctx.beginPath();
	    ctx.arc(explosions[i].x, explosions[i].y, explosions[i].size, 0, Math.PI * 2);
	    ctx.closePath();
	    ctx.fillStyle = explosions[i].color;
	    ctx.fill();
	    ctx.restore();
	  }
	}

    // Reset ship position
    function resetShip() {
      ship.x = canvas.width / 2;
      ship.y = canvas.height / 2;
      ship.velocityX = 0;
      ship.velocityY = 0;
    }

    function buySuperWeapon(weapon) {
      switch (weapon) {
        case 'missile':
          if (coins >= 200) {
            coins -= 200;
            superWeapons.missile++;
            updateMarketplaceDisplay();
          }
          break;
        case 'laser':
          if (coins >= 300) {
            coins -= 300;
            superWeapons.laser++;
            updateMarketplaceDisplay();
          }
          break;
        case 'bomb':
          if (coins >= 400) {
            coins -= 400;
            superWeapons.bomb++;
            updateMarketplaceDisplay();
          }
          break;
      }
    }

    function useSuperWeapon(weapon) {
      switch (weapon) {
        case 'missile':
          if (superWeapons.missile > 0) {
            superWeapons.missile--;
            activateMissile();
            updateMarketplaceDisplay();
            break;
          }
        case 'laser':
          if (superWeapons.laser > 0) {
            superWeapons.laser--;
            activateLaserBeam();
            updateMarketplaceDisplay();
            break;
          }
        case 'bomb':
          if (superWeapons.bomb > 0) {
            superWeapons.bomb--;
            activateBomb();
            updateMarketplaceDisplay();
            break;
          }
      }
    }

	// Function to update marketplace display
	function updateMarketplaceDisplay() {
	  coinsDisplay.textContent = coins;
	  laserLevelDisplay.textContent = ship.laserLevel;
	  accelerationLevelDisplay.textContent = ship.accelerationLevel;
	  rotationSpeedLevelDisplay.textContent = ship.rotationSpeedLevel;
	  droneSpeedLevelDisplay.textContent = droneUpgrades.speed;
	  droneLaserSpeedLevelDisplay.textContent = droneUpgrades.laserSpeed;
	  droneLaserIntervalLevelDisplay.textContent = droneUpgrades.laserInterval;
	}

    function activateMissile() {
      // Find the nearest asteroid to the ship
      let nearestAsteroid = null;
      let nearestDistance = Infinity;
      for (let i = 0; i < asteroids.length; i++) {
        let dx = ship.x - asteroids[i].x;
        let dy = ship.y - asteroids[i].y;
        let distance = Math.sqrt(dx * dx + dy * dy);
        if (distance < nearestDistance) {
          nearestAsteroid = asteroids[i];
          nearestDistance = distance;
        }
      }

      if (nearestAsteroid) {
        // Create an explosion at the nearest asteroid's position
        createExplosion(nearestAsteroid.x, nearestAsteroid.y);
        // Remove the nearest asteroid
        let index = asteroids.indexOf(nearestAsteroid);
        asteroids.splice(index, 1);
        score += 50;
      }
    }

    function activateLaserBeam() {
      // Destroy all asteroids in a straight line in front of the ship
      let angle = ship.rotation * Math.PI / 180;
      let startX = ship.x;
      let startY = ship.y;
      let endX = ship.x + canvas.width * Math.sin(angle);
      let endY = ship.y - canvas.width * Math.cos(angle);

      for (let i = asteroids.length - 1; i >= 0; i--) {
        if (isPointOnLine(asteroids[i].x, asteroids[i].y, startX, startY, endX, endY)) {
          createExplosion(asteroids[i].x, asteroids[i].y);
          asteroids.splice(i, 1);
          score += 50;
        }
      }
    }

    function isPointOnLine(px, py, startX, startY, endX, endY) {
      let threshold = 10; // Adjust this value to control the thickness of the laser beam
      let distance = Math.abs((endY - startY) * px - (endX - startX) * py + endX * startY - endY * startX) / Math.sqrt(Math.pow(endY - startY, 2) + Math.pow(endX - startX, 2));
      return distance <= threshold;
    }

    function activateBomb() {
      // Destroy all asteroids within a certain radius of the ship
      let bombRadius = 100; // Adjust this value to control the size of the bomb explosion
      for (let i = asteroids.length - 1; i >= 0; i--) {
        let dx = ship.x - asteroids[i].x;
        let dy = ship.y - asteroids[i].y;
        let distance = Math.sqrt(dx * dx + dy * dy);
        if (distance <= bombRadius) {
          createExplosion(asteroids[i].x, asteroids[i].y);
          asteroids.splice(i, 1);
          score += 50;
        }
      }
    }

    // Handle keyboard input
    function handleKeyDown(event) {
      if (event.key === 'ArrowUp') {
        if (ship.speed < ship.maxSpeed) {
          ship.speed += ship.acceleration;
        }
      } else if (event.key === 'ArrowDown') {
        if (ship.speed > 0) {
          ship.speed -= ship.acceleration;
        }
      } else if (event.key === 'ArrowLeft') {
        ship.rotation -= ship.rotationSpeed;
      } else if (event.key === 'ArrowRight') {
        ship.rotation += ship.rotationSpeed;
      } else if (event.key === ' ') {
        ship.lasers.push({ x: ship.x, y: ship.y, rotation: ship.rotation, size: 2 });
      } else if (event.key === 's') {

      	    if (marketplace.style.display === 'block') {
				exitMarketplace();

		    } else {
		      pauseGameForMarketplace();
		    }

      }
    }

    function handleKeyUp(event) {
      if (event.key === 'ArrowUp' || event.key === 'ArrowDown') {
        ship.speed = 0;
      }
    }



	window.addEventListener('resize', resizeCanvas);

	joystick.addEventListener('touchstart', (e) => {
	  isTouchingJoystick = true;
	  joystickStartX = e.touches[0].clientX;
	  joystickStartY = e.touches[0].clientY;
	});

	joystick.addEventListener('touchmove', (e) => {
	  if (isTouchingJoystick) {
	    const touchX = e.touches[0].clientX;
	    const touchY = e.touches[0].clientY;
	    const deltaX = touchX - joystickStartX;
	    const deltaY = touchY - joystickStartY;

	    // Calculate angle and distance from the center
	    const angle = Math.atan2(deltaY, deltaX);
	    const distance = Math.min(Math.sqrt(deltaX * deltaX + deltaY * deltaY), 50); // Limit the joystick handle movement

	    // Update joystick handle position
	    joystickHandle.style.transform = `translate(${distance * Math.cos(angle)}px, ${distance * Math.sin(angle)}px)`;

	    // Update ship rotation and speed based on joystick movement
	    ship.rotation = angle * (180 / Math.PI); // Convert radians to degrees
	    ship.speed = Math.min(distance / 10, ship.maxSpeed); // Adjust speed based on distance, ensure it doesn't exceed maxSpeed

	    e.preventDefault();
	  }
	});

	joystick.addEventListener('touchend', () => {
	  isTouchingJoystick = false;
	  ship.speed = 0;
	  joystickHandle.style.transform = 'translate(-50%, -50%)'; // Reset joystick handle position
	});

	restartButton.addEventListener('click', () => {
	  restartButton.style.display = 'none';
	  lives = 3;
	  score = 0;
	  coins = 0;
	  wave = 1;
	  coins += bonusCoins;
	  asteroids = [];
	  drones = [];
	  droneUpgrades = {
	  speed: 1,
	  laserSpeed: 1,
	  laserInterval: 1
		};
		
	  ship.laserLevel = 1;
	  ship.accelerationLevel = 1;
	  ship.rotationSpeedLevel = 1;

	  gameOver = false;
	  invincible = true;
	  invincibilityTimer = invincibilityDuration;
	  createAsteroids();
	  startGame();
	});

    // Start the game
    startGame();
  </script>
</body>
</html>
